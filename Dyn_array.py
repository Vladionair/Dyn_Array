gAAAAABfUQMU6cXXIO0knpjwwc_3zGUEoErPnYTgdn4c7UNCdWtLtOA8tHHMzSshLWN5HlT_XreIDiEw8JuRglnYCZby-Wpb_Oed6s0Y94fusMCTUfkeJ4z0kteMoYipV_ngAHMw2EzgHPpLWP8OxqRZmrgtGM5BF61uSPWQvLvpyxRqYpe983S7NHqIOt8WIj8cTsdyuy8cJAaqSN2fJyg-UoGR4n_QwWkT6xFfhVB-o_7YUuPB9eqFTFKe9xywJxdGZo4A3max_wC0YrBybzWac6ptJj0N1KVXYqxzIft2eZV8J2nbaNzULD3Ap4JK4PqsoDLEbCoPphz0Mo0hJyxMkmDAHqOWnEijK_iGxvIE-U_-umatRpayFPusl4jwbS8obODnMTtWO3v2FnOnD-CTHbNMQF5yrz35KxTCirmjGVLPEV6RzopH7taXwY6cZB2s9pt_b7EiLsi1R4YpdLZdL1N-JKzug1aomyluDwvwkpZcJKrVQ7XQW01ehXz0eD5a9FeyAL2NWUwbStF1gJoQBOnfwXfJe6lHn8So8RiwuLmvoqfRTTleFKWzeL70hfKqk1Ab2IHP7VUUxEIwCL5Jib_rjplu9do-GLPp7MocWhLWiCQLHzfheTEO4lC3fOajQIcM-eavG4W0gULUornFNhPqu8Oygmk_VMoET4CYsJNFvu6iKC5rlVn1NSuQHRNkCeO_ZDlBtKf9Du_j2WvLMXaEnMfc9Dzi8uHyfIYrQAxLr0JyBmfgsTHRqL5yOOdHTmug5wrl3TYoD0Lij8UPYW8abHRftskXvxl_EjmVFoVDjXwqVFSviG-0yh1C_13IihU7KlRn954tIFiZh4Z5IWYcRdX5vIvPkN53zC0TKUg6P0c2rvuiLSP1PbzaliEWfsSZORfpQkqAWnl-wYFInMKizAuQzbYYl5P5BBooINjuKIvaIwPlj1FpCyZcdthlB-3WA9SCdQ8FmGRWWItyxOQ0HCjlJ0tW6mt41g7qBo6gvF_vkmHvuV_zFVr4pXnTlR0nPv50fH1Tv8wviAiK0nOzgPfR_e7kE5psPmpiUzjyoLezWP7Si2i8n0HevGCB47gVmq-aHHdpZDO0zleC7mnMYBFE5BmSEm0q6VtGwHEe7nKTqwJ1krGoPKiRwHuV67z6WOAqhT27eqfeGihTs-oHMc1J2j1KW7SYzFKSPYbKSVhczKhRNuaFoL8Ar8VxheVQDmmOXTEdKIsnXHLU1RkiqHyZnjT-UBHF_5OrFTpztfIbd8vkFXtKtgAXy3axQzmZPA-dYYROizIOo6xUnDNng0M0qHki7l5eVogz_hzMgfAPPV_FMLqltyqsdFYVnniUnK4w_U5qIu2Nnc6OecObL_Je_E6FsVE9fwITPK87amnBjQyHMaCjYWL5plZl4C9GyTgbaYIZCK6c22g6Rc3_fRzRMc_K2bjLNko4A3iQtRIBaxLfpS9KmiNVU-Sa6Hc6878EClppKyU2f32Hulv5NIkKIkWjfvUbkcCA3lOpj4vJDCiB1Xif2xSLIB1If-NRJ6Q30xbeauQwHLQ5d2BtK4DTOkJUiD2sanxfOfxq8AwI0ZANH1hkJW6CM_Amrd-UEHzwaK5QpTchbWOdbdVHaUbKxTQugD5dI66Yh0lhZGK90WVVFSVy3g6Lqh8gu-ilDu1Zl8mjkR0ZAitPaHXJDEsW7QUBfFaRzTp0_e6K5EEnyeWQqskYCWoUyTe9Z3CxX3GqGRP12CyovMQl7g2iVWGgF540s4GWpSBi8czB0SGSMbXbjBztAM7XG5JK-_ZWd_y0wFkrcc575Vfrv1nyXf0Sh5x1l0Z4aF86iocUOThWKBV6LK9FdL9YJkOTy0rbF2qaUXkG-YNA-2oczxzfoR0Rh9g-sKRs4UK823yt_DYIz5d7IMW6NonjfE3xETb9xSvbgJ8BPVYu6IkE8Z34NWxbeZSXlKcQECjmebmm4f1Kry6gdvMrg9skRMW6IGu_UbtUQu-xbSctU9IEj64LPgZipKaoMfKyTrZ4v_c9RK42_NKYjfs8bbnasAAPo9-GPZThRjbpArxK25JZbJ6yye805F4bfpgWkB6v-TXcztLWu-IHKk5txv7yds5yxSIO2dpVWU8b-_YlJ2Ah2kI1xAOjakkPyqrscV-Ygs6Hm-t_Fv6cgFchbPVVMlzcVjVYMv1yLCYv-myi055i1GhH7yB6SAmOBDrrD1PV_2zjt4fDoeBQtavMWMRcrtiCL-5L3140RCfjIv3K9pEmgdLhdQJfeixNeJEfkPqpWyIfYfRUBttGDwxPxG3NDHMAGX5gNK8H868gTALFfJzf7OkcW_FHCXvmFUpBAxLedUTTycezl68Dck0wKfv9sFWOHpQU09WswpBoHRyVZfCbcUYW2skAhA3LjEqVoRBLb5SWa0tpXSCSfZPZYJzQEcxcPOXhhAye65Sg4roXWdspgk7TlIomkJRgJyrYgXzKPGLm1LVYEeVHXFNVKmuXEH8W7Gwn01ex9fkNxK0ZOQd9Q3REXHFPZvRd9CaAOxoswsoVOYffw-RblgCs6tJdPq3PNZ59rmWO-1691-fD8xr6ghzjyxypL3Nw9GnWSRMENSGPCs4NrV3hCm2A_54u9xi8rLH6en8luxvt-IW9QqZ-ZbDMlyqgwJxEiKHfsgcwXKc-kwrISUCREDcK8COVn7YSNupSBW0P5dXQn0aGdj1TUwTKACG630TetahqMYUnJa9L7mrRliaOdXiRTgrCNejEtOz5l4lvHejVoWJyGoSSxpRGLvuHVMxox77G0be0DNAI3cV4I73XtjLbVm4kkZsujsMw9NXSYfqqXTF4zpk_4ubPft8kS2hlG9tfHBthej18Twk91CkIo1DW9rCC_OB4CdLjx-7qWoDTZ4QIFRb7L0F63cbQavMh6VrPHe9RtbM_qACvcW2IddsugGcUKZj4g8F4kgPyga_aXU4-XlL-DTpDe9LtyfJgwGIokxkLT8oJ89PhE-VZpw2HH7H-uMmbQuMGpzMoWf1Rz37zwftB2V8dwxPsyDrlbAKcnKPZA4ooPaJF4ep3MTauHyprPSVqukLuEXrPIOPQcJ0VQvnSPyS6rkhn4hGh2kGeQQSTRdXzRp6VOizp2TJqOLHdbAHvW-7ckrkCIsxW2vsZxDQaThdPrAMlzacbbHacWp6538xJC_Yhxu_ssswedr6RzMJH-6v1OQQH6wrAvzn44qkcC8g7R5WMdkqkz4vLBaXigLcazftvvIJy8mnL8aFUIVbnCFSpYgnnbZzfY4LU6gwExIkH468bRufqh5pmbgvFVgcu4d19CjcVQH6za-twMdI4xuuvLRoWnCIm-GzGQNuEBiqQIHCYWk3u2ZCONChbLZEAO9Ep8QYrFqM_gCMoRmiKiUD29Vl-fTbNxIaDEKgjTu7xsueFjh9pklgtVum5ziKGbwPsJfzQ_c_x8xiauuF8VQ_dFm-FzUCLwj53sI0HZJMbRMhWwaFPkwzRVastGz0Tk4uQ30Zj58lXo-_E3H7vSKL4Motx3YKrseoCk4GzRKoJIAWwb5VNLHjHTAjhlsrihJcHw_JiiOWPBKnKUCS5HYzuk2isTOEq-hfIZ-ekIQd5M7ENiBN-eBbIS8hpJN-ZgSOnZT1SEisI32ToAZPiQCzZwlfBxE0_50Od1pkrQrAdPPZJR4PVkK7L1FJuW9DaZxVSO6QygJsdF2DqW7zwyGz1yBkNWKxs3X0av_ZiTGX3hdjJzT4DPwYVJTOI54qfIz-QRHmKt2fxxbm7jHRnkVS7piO3xHVlyBUbm4h8U6Svw9vgmAYgHqSJGbs2KiiKvLsjhjHs98UNXp5qfFclN6mmrwPYUSqfCpOIWueW1UIHcZ2QwgNHGTwne_w3fEJfrIgPi2wHmlDX4n8VfM9N0cN7MfsmsEgQX3zwXnIMS26iU5o4U8VqT0eH1fg3Z3Y9mUWR5TDL4zgmw7U_v6drEi4jY0ZFD-itbNwW_sU-l4AUZybLfAq8wrEkgxqUzIeEe_fgJOd4mZKE-Sw0NNayo-Sw5QC7Eed9nXSFNJBbE82H_n17L-VwroaH_91Cvo3qz2BEzK22TQJEmnbH6edbV0Vjued_AQSBP8IBpg6mSzJXfyN9LzhRjMH1vNSPBBC0e6zv5v54WnKRfrnBFEbD8meM1hvQUnIzuode9sWaxTJAoJVWvOINDguzTTdAL47f3eT-7Oe10t-_SscNzmRkrXDlncOK4wHZPLU_ji-iEgf2K4lCrbQQTJWDRjajgKEwhdwNjzyjLafqSmSpc08Ap5vWCBtLvVHU0KYkqj1DyZw0E55_BH3XZq2LeYWeZCrfQblVeQL74ArmePavu6NHG4UgKnjbpUuWY_zd894PQjk--2mG5aUXC_U8JOBfIomWL5FnWhMA5tIVg-krWvPkitBdKHtdx8o7-8Z3m8lvbd-7pmxHSgfTRh7YgPyemJflxkJcbFsn_8aXo3YgcikezabrqwNUWQbxwzySqMQqcz2me2vmh9OV9scvSW_JY0DK0XhR5JNpRux6fZGceaBcWhEIab1aL2unV97IQ3T2m4NLwZI0ZGXRRd4dug9JywXpjXHa4JCSXLGE3Jbu3VyLe3Wh5Cs_GP93gVm4RkOB_mXt9RL_wNhoXxAuhLZPb0vrhSrRwEmUt94gypsZjEI7AF5MwCknEltwt-ukbjzYqI8i5ENWl5gU3IKlvXlTCAwnZ1eHskK2MqviO6ua8PiKXOsp-R1qGjsA9Vx8y0bTYo22tPyse56uUk23BwfUXLpoZXfyHIbRSDArqk1G8GH8PvAaRgx6RmivsIiFrB6FzGOe9iVpMuID0XDSlCnb81jjy2PkjgV5GQuNiD4XA8PDO3UV4nlB01Z0wV0ek-AmpI0hjUEizAkYJ7I0eC2ybJtoUJUUFrB_a01X95IFxk-o5zyaVmbWUU0n0Ns6JGzkWWuVryN9MnuSUmtJwKj1KW3LgXMDsgocYpn-7M28YJbkuPfMr77BV0gdOP6ZJDb4nENDg7h7e2R3OKW6HZPw1gWPsuCNkkzGcuOYCQGMH5_LuRzCBM6ycqK9QdUjeDYruuc3O7YzSg==

import ctypes

class DynArray:

    def __init__(self):
        
        self.count = 0
        self.capacity = 16
        self.array = self.make_array(self.capacity)

    def __len__(self):
        
        return self.count

    def make_array(self, new_capacity):
        
        return (new_capacity * ctypes.py_object)()

    def __getitem__(self, i):
        
        if i < 0 or i >= self.count:
            raise IndexError('Index is out of bounds')
        return self.array[i]

    def resize(self, new_capacity):
        
        new_array = self.make_array(new_capacity)
        for i in range(self.count):
            new_array[i] = self.array[i]
        self.array = new_array
        self.capacity = new_capacity

    def append(self, itm):
        
        if self.count == self.capacity:
            self.resize(2 * self.capacity)
        self.array[self.count] = itm
        self.count += 1

    def insert(self, i, itm):
        
        if i < 0 or i > self.count:
            raise IndexError('Index is out of bounds')
        else:
            if self.count == self.capacity:
                self.resize(2 * self.capacity)
            if i == self.count:
                self.array[i] = itm
                self.count += 1
                return
            else:
                for j in range(self.count, -1, -1):
                    if j > i:
                        self.array[j] = self.array[j - 1]
                    else:
                        self.array[i] = itm
                        self.count += 1
                        return

    def delete(self, i):
        
        if i < 0 or i >= self.count:
            raise IndexError('Index is out of bounds')
        else:
            for j in range(self.count):
                if j == i:
                    for k in range(j, self.count - 1):
                        self.array[k] = self.array[k + 1]
                    self.count -= 1
                    if self.count < self.capacity / 2:
                        if int(self.capacity / 1.5) > 16:
                            self.resize(int(self.capacity / 1.5))
                            return
                        else:
                            self.resize(16)
                            return
                    else:
                        return

import unittest

class Test_DynArray(unittest.TestCase):

    def setUp(self):
        
        da_test.__init__()

    def test_insert_no_buff(self):
        
        for i in range(10):
            da_test.append(i)
        da_test.insert(0, 111)
        self.assertEqual(da_test[0], 111)
        self.assertEqual(da_test.capacity, 16)

    def test_insert_buff(self):
        
        for i in range(16):
            da_test.append(i)
        da_test.insert(16, 111)
        self.assertEqual(da_test[16], 111)
        self.assertEqual(da_test.capacity, 32)

    def test_insert_index(self):
        
        try:
            da_test.insert(-1, 111)
            da_test.insert(1, 111)
        except IndexError:
            pass

    def test_delete_no_buff(self):
        
        for i in range(10):
            da_test.append(i)
        da_test.delete(0)
        self.assertEqual(da_test.count, 9)
        self.assertEqual(da_test.capacity, 16)

    def test_delete_buff(self):
        
        for i in range(17):
            da_test.append(i)
        for i in range(10):
            da_test.delete(0)
        self.assertEqual(da_test.count, 7)
        self.assertEqual(da_test.capacity, 16)

    def test_delete_index(self):
        
        try:
            da_test.delete(-1)
            da_test.delete(1)
        except IndexError:
            pass

if __name__ == '__main__':
    
    da_test = DynArray()
    unittest.main(verbosity=2)
